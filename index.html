<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=1200, initial-scale=1" />
    <title>X Cropper</title>
    <style>
      :root {
        --bg: #f6f6f6;
        --bg-strong: #ffffff;
        --fg: #0d0d0d;
        --muted: #6c6c6c;
        --line: #0d0d0d;
        --line-soft: #d9d9d9;
        --shadow: 0 18px 40px rgba(0, 0, 0, 0.08);
        --radius: 16px;
        --gap: 24px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        color: var(--fg);
        font-family: "PingFang SC", "PingFang TC", "PingFang HK", "PingFang",
          "Noto Sans CJK SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
        background-image: radial-gradient(
            rgba(0, 0, 0, 0.05) 0.6px,
            transparent 0.6px
          ),
          linear-gradient(135deg, #f9f9f9 0%, #ededed 100%);
        background-size: 14px 14px, cover;
        min-height: 100vh;
        overflow: hidden;
      }

      button,
      input,
      select {
        font-family: inherit;
      }

      .page {
        width: 100%;
        margin: 0 auto;
        padding: 20px 100px 24px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        height: 100vh;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
      }

      .title {
        font-size: clamp(22px, 3vw, 34px);
        font-weight: 300;
        letter-spacing: 0.08em;
        text-transform: none;
      }

      .title-snap {
        font-size: 1em;
        letter-spacing: inherit;
        font-weight: inherit;
      }

      .header-actions {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .icon-link {
        width: 36px;
        height: 36px;
        border: 1px solid var(--line);
        border-radius: 999px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: #fff;
        color: var(--fg);
        text-decoration: none;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .icon-link:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
      }

      .icon-link svg {
        width: 16px;
        height: 16px;
        display: block;
        fill: currentColor;
      }

      .subtitle {
        font-size: 15px;
        line-height: 1.6;
        max-width: 760px;
        color: var(--muted);
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.18em;
        color: var(--muted);
      }

      .workspace {
        display: grid;
        grid-template-columns: minmax(260px, 340px) minmax(0, 1fr) minmax(220px, 340px);
        gap: 18px;
        align-items: start;
      }

      .panel {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }

      .card {
        position: relative;
        background: var(--bg-strong);
        border: 1px solid var(--line);
        border-radius: var(--radius);
        padding: 16px 16px 14px;
        box-shadow: var(--shadow);
      }

      .card-title {
        font-size: 14px;
        font-weight: 600;
        margin: 0 0 10px;
        text-transform: uppercase;
        letter-spacing: 0.18em;
      }

      .upload-area {
        border: 1px dashed var(--line);
        border-radius: 12px;
        padding: 18px;
        display: grid;
        gap: 12px;
        text-align: center;
        background: #fbfbfb;
        transition: border-color 0.2s ease, background 0.2s ease;
      }

      .upload-area.dragging {
        border-color: var(--fg);
        background: #f1f1f1;
      }

      .upload-area input {
        display: none;
      }

      .upload-actions {
        display: flex;
        justify-content: center;
        gap: 10px;
        flex-wrap: wrap;
      }

      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: 12px;
        border: 1px solid var(--line);
        padding: 10px 18px;
        background: var(--fg);
        color: #fff;
        cursor: pointer;
        font-size: 14px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .btn.ghost {
        background: transparent;
        color: var(--fg);
      }

      .hint {
        font-size: 12px;
        color: var(--muted);
      }

      .scheme-grid {
        display: grid;
        gap: 10px;
      }

      .scheme-card {
        display: grid;
        gap: 10px;
      }

      .scheme-card input {
        display: none;
      }

      .scheme-body {
        border: 1px solid var(--line-soft);
        border-radius: 12px;
        padding: 12px 14px;
        display: grid;
        gap: 10px;
        background: #fff;
        cursor: pointer;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .scheme-card input:checked + .scheme-body {
        border-color: var(--line);
        box-shadow: 0 10px 18px rgba(0, 0, 0, 0.08);
      }

      .scheme-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 6px;
        font-size: 14px;
        font-weight: 600;
      }

      .scheme-tag {
        font-size: 12px;
        letter-spacing: 0.04em;
        text-transform: none;
        color: var(--muted);
      }

      .scheme-mini {
        display: grid;
        gap: 2px;
        width: 72px;
        height: 44px;
        border: 1px solid var(--line);
        border-radius: 8px;
        overflow: hidden;
      }

      .scheme-mini div {
        background: #e8e8e8;
      }

      .scheme-mini.quad {
        grid-template-columns: repeat(2, 1fr);
        grid-template-rows: repeat(2, 1fr);
      }

      .scheme-mini.duo {
        grid-template-columns: repeat(2, 1fr);
        grid-template-rows: 1fr;
      }

      .scheme-mini.vertical {
        grid-template-columns: 1fr;
        grid-template-rows: repeat(4, 1fr);
        width: 52px;
        height: 88px;
      }

      .controls {
        display: grid;
        gap: 10px;
      }

      .control-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        font-size: 12px;
      }

      .control-row input[type="range"] {
        flex: 1;
        accent-color: #000;
      }

      .control-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .control-actions button {
        border-radius: 12px;
        border: 1px solid var(--line);
        padding: 8px 12px;
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }

      .control-actions button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .primary-action {
        width: 100%;
        border-radius: 12px;
        padding: 12px 16px;
        font-size: 14px;
        letter-spacing: 0.14em;
        text-transform: uppercase;
      }

      .primary-action:disabled {
        cursor: not-allowed;
        opacity: 0.5;
        box-shadow: none;
        transform: none;
      }

      .stage-panel {
        display: grid;
        gap: 12px;
      }

      .results-panel {
        display: grid;
        gap: 12px;
      }

      .stage-wrap {
        background: var(--bg-strong);
        border: 1px solid var(--line);
        border-radius: var(--radius);
        padding: 12px;
        box-shadow: var(--shadow);
        display: grid;
        gap: 8px;
      }

      .stage {
        --stage-max-height: 52vh;
        --grid-gap: 6px;
        --stage-radius: 12px;
        position: relative;
        width: min(100%, calc(var(--stage-max-height) * var(--stage-ratio, 1)));
        aspect-ratio: var(--stage-ratio, 16 / 9);
        background: #fff;
        border-radius: var(--stage-radius);
        overflow: hidden;
        cursor: grab;
        margin: 0 auto;
      }

      .stage:active {
        cursor: grabbing;
      }

      .stage img {
        position: absolute;
        top: 0;
        left: 0;
        transform-origin: top left;
        user-select: none;
        pointer-events: none;
      }

      #source-image {
        opacity: 0;
        z-index: 0;
      }

      .tile-grid {
        position: absolute;
        inset: 0;
        display: grid;
        grid-template-columns: repeat(var(--cols, 1), 1fr);
        grid-template-rows: repeat(var(--rows, 1), 1fr);
        gap: var(--grid-gap);
        pointer-events: none;
        z-index: 1;
      }

      .tile-cell {
        position: relative;
        overflow: hidden;
        background: #fff;
        border: 1px solid var(--line);
      }

      .tile-image {
        width: auto;
        height: auto;
      }

      .stage-placeholder {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 13px;
        color: var(--muted);
        background: repeating-linear-gradient(
          135deg,
          #fafafa 0px,
          #fafafa 10px,
          #f2f2f2 10px,
          #f2f2f2 20px
        );
        transition: opacity 0.2s ease;
        z-index: 2;
      }

      .stage[data-loaded="true"] .stage-placeholder {
        opacity: 0;
        pointer-events: none;
      }

      .results {
        display: grid;
        gap: 10px;
        background: var(--bg-strong);
        border: 1px solid var(--line);
        border-radius: var(--radius);
        padding: 16px 16px 14px;
        box-shadow: var(--shadow);
      }

      .results-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .results-title {
        margin: 0;
        font-size: 16px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      .output-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
        align-content: start;
        align-items: start;
        grid-auto-rows: max-content;
      }

      .output-grid.vertical-stack {
        grid-template-columns: minmax(160px, 200px);
        justify-content: start;
      }

      .output-card {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 8px;
        display: grid;
        gap: 8px;
        background: #fff;
      }

      .output-card img {
        width: 100%;
        height: auto;
        display: block;
        border-radius: 8px;
        border: 1px solid var(--line-soft);
        background: #fafafa;
      }

      .output-meta {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 12px;
      }

      .output-meta a,
      .output-meta button {
        color: var(--fg);
        text-decoration: none;
        border: 1px solid var(--line);
        padding: 6px 10px;
        border-radius: 12px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        font-size: 11px;
        background: #fff;
        cursor: pointer;
      }

      .output-empty {
        min-height: 120px;
        border: 1px dashed var(--line-soft);
        border-radius: 12px;
        background: #fafafa;
      }

    </style>
  </head>
  <body>
    <div class="page">
      <header>
        <div class="title">ùïè <span class="title-snap">Cropper</span></div>
        <div class="header-actions">
          <a class="icon-link" href="https://x.com/wolfyxbt" target="_blank" rel="noopener" aria-label="X">
            <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <path
                d="M14.234 10.162 22.977 0h-2.072l-7.591 8.824L7.251 0H.258l9.168 13.343L.258 24H2.33l8.016-9.318L16.749 24h6.993zm-2.837 3.299-.929-1.329L3.076 1.56h3.182l5.965 8.532.929 1.329 7.754 11.09h-3.182z"
              />
            </svg>
          </a>
          <a
            class="icon-link"
            href="https://github.com/wolfyxbt/XCropper"
            target="_blank"
            rel="noopener"
            aria-label="GitHub"
          >
            <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
              <path
                d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"
              />
            </svg>
          </a>
        </div>
      </header>

      <main class="workspace">
        <section class="panel">
          <div class="card" id="upload-card">
            <h2 class="card-title">‰∏ä‰º†</h2>
            <div class="upload-area" id="upload-area">
              <input id="file-input" type="file" accept="image/*" />
              <div class="upload-actions">
                <button class="btn" id="select-btn" type="button">‰∏ä‰º†ÂõæÁâá</button>
                <button class="btn ghost" id="paste-btn" type="button">Á≤òË¥¥ÂõæÁâá</button>
              </div>
            </div>
          </div>

          <div class="card" id="selection-card">
            <h2 class="card-title">ÈÄâÊã©</h2>
            <div class="scheme-grid">
              <label class="scheme-card">
                <input type="radio" name="scheme" value="quad" checked />
                <div class="scheme-body">
                  <div class="scheme-head">
                    <span>ÂõõÂêà‰∏Ä</span>
                    <span class="scheme-tag">ùïè ÁöÑÂ§ñÈÉ®È¢ÑËßàÊãºÊàê 2x2 ÁöÑÂÆåÊï¥ÁîªÈù¢</span>
                  </div>
                  <div class="scheme-mini quad">
                    <div></div>
                    <div></div>
                    <div></div>
                    <div></div>
                  </div>
                </div>
              </label>

              <label class="scheme-card">
                <input type="radio" name="scheme" value="duo" />
                <div class="scheme-body">
                  <div class="scheme-head">
                    <span>‰∫åÂêà‰∏Ä</span>
                    <span class="scheme-tag">ùïè ÁöÑÂ§ñÈÉ®È¢ÑËßàÊãºÊàê 1x2 ÁöÑÂÆåÊï¥ÁîªÈù¢</span>
                  </div>
                  <div class="scheme-mini duo">
                    <div></div>
                    <div></div>
                  </div>
                </div>
              </label>

              <label class="scheme-card">
                <input type="radio" name="scheme" value="vertical" />
                <div class="scheme-body">
                  <div class="scheme-head">
                    <span>ÂûÇÁõ¥ÈïøÂõæ</span>
                    <span class="scheme-tag">ùïè ÁöÑÂÜÖÈÉ®ÊµèËßàÊãºÊàê 4x1 ÁöÑÂÆåÊï¥ÁîªÈù¢</span>
                  </div>
                  <div class="scheme-mini vertical">
                    <div></div>
                    <div></div>
                    <div></div>
                    <div></div>
                  </div>
                </div>
              </label>
            </div>
          </div>

          <div class="card" id="adjust-card">
            <h2 class="card-title">Ë∞ÉÊï¥</h2>
            <div class="controls">
              <div class="control-row">
                <span>Áº©Êîæ</span>
                <input id="zoom-range" type="range" min="1" max="3" step="0.01" value="1" />
                <span id="zoom-value">1.00x</span>
              </div>
              <div class="control-actions">
                <button type="button" id="fit-btn">ÈÄÇÈÖç</button>
                <button type="button" id="center-btn">Â±Ö‰∏≠</button>
                <button type="button" id="rotate-btn" disabled>ÊóãËΩ¨</button>
                <button type="button" id="mirror-btn" disabled>ÈïúÂÉè</button>
              </div>
            </div>
          </div>
        </section>

        <section class="stage-panel">
          <div class="stage-wrap">
            <div class="stage" id="stage" data-loaded="false">
              <div class="tile-grid" id="tile-grid"></div>
              <img id="source-image" alt="uploaded" />
              <div class="stage-placeholder">ÂõæÁâáÈ¢ÑËßà</div>
            </div>
          </div>
        </section>

        <section class="results-panel">
          <div class="card">
            <button class="btn primary-action" id="crop-btn" disabled>Á°ÆËÆ§Ë£ÅÂàá</button>
          </div>
          <div class="results">
            <div class="results-header">
              <h2 class="results-title">ÁªìÊûú</h2>
            </div>
            <div class="output-grid" id="output-grid">
              <div class="output-empty" aria-hidden="true"></div>
            </div>
          </div>
        </section>
      </main>
    </div>

    <script>
      const schemes = {
        quad: {
          id: "quad",
          name: "ÂõõÂêà‰∏Ä",
          cols: 2,
          rows: 2,
          cellW: 257,
          cellH: 144.13,
        },
        duo: {
          id: "duo",
          name: "‰∫åÂêà‰∏Ä",
          cols: 2,
          rows: 1,
          cellW: 257,
          cellH: 290.25,
        },
        vertical: {
          id: "vertical",
          name: "ÂûÇÁõ¥ÈïøÂõæ",
          cols: 1,
          rows: 4,
          cellW: 257,
          cellH: 144.13,
        },
      };

      const state = {
        scheme: schemes.quad,
        imageLoaded: false,
        originalImage: null,
        rotation: 0,
        mirror: false,
        imgWidth: 0,
        imgHeight: 0,
        scale: 1,
        minScale: 1,
        maxScale: 3,
        offsetX: 0,
        offsetY: 0,
        dragging: false,
        dragStartX: 0,
        dragStartY: 0,
        dragOriginX: 0,
        dragOriginY: 0,
      };

      const fileInput = document.getElementById("file-input");
      const uploadArea = document.getElementById("upload-area");
      const selectBtn = document.getElementById("select-btn");
      const pasteBtn = document.getElementById("paste-btn");
      const leftPanel = document.querySelector(".panel");
      const uploadCard = document.getElementById("upload-card");
      const selectionCard = document.getElementById("selection-card");
      const adjustCard = document.getElementById("adjust-card");
      const stage = document.getElementById("stage");
      const stageWrap = document.querySelector(".stage-wrap");
      const resultsCard = document.querySelector(".results");
      const resultsHeader = document.querySelector(".results-header");
      const sourceImage = document.getElementById("source-image");
      const zoomRange = document.getElementById("zoom-range");
      const zoomValue = document.getElementById("zoom-value");
      const fitBtn = document.getElementById("fit-btn");
      const centerBtn = document.getElementById("center-btn");
      const rotateBtn = document.getElementById("rotate-btn");
      const mirrorBtn = document.getElementById("mirror-btn");
      const cropBtn = document.getElementById("crop-btn");
      const tileGrid = document.getElementById("tile-grid");
      const outputGrid = document.getElementById("output-grid");

      const tiles = [];
      let verticalLayoutScheduled = false;
      let pendingFit = false;
      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
      const getGridGap = () => {
        const value = getComputedStyle(stage).getPropertyValue("--grid-gap");
        const parsed = parseFloat(value);
        return Number.isFinite(parsed) ? parsed : 0;
      };
      const getContentMetrics = () => {
        const rect = stage.getBoundingClientRect();
        const gap = getGridGap();
        const { cols, rows } = state.scheme;
        const contentW = rect.width - gap * (cols - 1);
        const contentH = rect.height - gap * (rows - 1);
        const cellW = contentW / cols;
        const cellH = contentH / rows;
        return { rect, gap, cols, rows, contentW, contentH, cellW, cellH };
      };
      const mapStageToContent = (value, cell, gap, count) => {
        const segment = cell + gap;
        const maxStage = segment * count - gap;
        const clamped = clamp(value, 0, maxStage);
        const index = Math.min(count - 1, Math.floor(clamped / segment));
        const within = clamped - index * segment;
        return index * cell + Math.min(within, cell);
      };

      const getOutputCardHeightEstimate = (scheme = state.scheme, columnWidth = null) => {
        const gridStyles = getComputedStyle(outputGrid);
        const columns = gridStyles.gridTemplateColumns.split(" ");
        const gridWidth = outputGrid.getBoundingClientRect().width || 0;
        const resolvedColumnWidth =
          columnWidth ||
          parseFloat(columns[0]) ||
          (scheme.id === "vertical" ? gridWidth : gridWidth / 2) ||
          160;
        const ratio = scheme.cellW / scheme.cellH;

        const tempCard = document.createElement("div");
        tempCard.className = "output-card";
        tempCard.style.position = "absolute";
        tempCard.style.visibility = "hidden";
        tempCard.style.pointerEvents = "none";
        tempCard.style.width = `${resolvedColumnWidth}px`;
        tempCard.style.left = "-9999px";
        tempCard.style.top = "0";

        const tempImg = document.createElement("img");
        tempImg.style.width = "100%";
        tempImg.style.height = "auto";
        tempImg.style.aspectRatio = `${ratio}`;
        tempImg.src =
          "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";

        const meta = document.createElement("div");
        meta.className = "output-meta";
        const btn1 = document.createElement("button");
        btn1.textContent = "‰∏ãËΩΩ";
        const btn2 = document.createElement("button");
        btn2.textContent = "Â§çÂà∂";
        meta.appendChild(btn1);
        meta.appendChild(btn2);

        tempCard.appendChild(tempImg);
        tempCard.appendChild(meta);
        outputGrid.appendChild(tempCard);
        const height = tempCard.getBoundingClientRect().height || 0;
        tempCard.remove();
        return height;
      };

      const getVerticalBaseline = () => {
        const gridStyles = getComputedStyle(outputGrid);
        const rowGap = parseFloat(gridStyles.rowGap || gridStyles.gap) || 0;
        const resultsStyles = getComputedStyle(resultsCard);
        const resultsPadY =
          parseFloat(resultsStyles.paddingTop) + parseFloat(resultsStyles.paddingBottom);
        const headerHeight = resultsHeader.getBoundingClientRect().height;
        const gridWidth = outputGrid.getBoundingClientRect().width || 0;
        const columnWidth = Math.min(200, Math.max(160, gridWidth || 160));
        const cardHeight = getOutputCardHeightEstimate(schemes.vertical, columnWidth);
        const stackHeight =
          cardHeight * schemes.vertical.rows + rowGap * (schemes.vertical.rows - 1);
        const resultsMinHeight = Math.max(
          headerHeight + resultsPadY + stackHeight,
          160
        );
        const resultsTop = resultsCard.getBoundingClientRect().top;
        const panelTop = leftPanel.getBoundingClientRect().top;
        const gap = parseFloat(getComputedStyle(leftPanel).gap) || 0;
        const uploadHeight = uploadCard.getBoundingClientRect().height;
        const adjustHeight = adjustCard.getBoundingClientRect().height;
        const resultsBottom = resultsTop + resultsMinHeight;
        const targetPanelHeight = Math.max(resultsBottom - panelTop, 0);
        const targetSelectionHeight = Math.max(
          targetPanelHeight - uploadHeight - adjustHeight - gap * 2,
          0
        );
        return {
          resultsMinHeight,
          resultsBottom,
          targetPanelHeight,
          targetSelectionHeight,
        };
      };

      const updateVerticalLayout = () => {
        stage.style.setProperty("--stage-max-height", "52vh");
        selectionCard.style.removeProperty("min-height");
        leftPanel.style.removeProperty("min-height");
        outputGrid.style.removeProperty("min-height");
        resultsCard.style.removeProperty("min-height");

        const baseline = getVerticalBaseline();
        resultsCard.style.minHeight = `${Math.round(baseline.resultsMinHeight)}px`;
        selectionCard.style.minHeight = `${Math.round(baseline.targetSelectionHeight)}px`;
        leftPanel.style.minHeight = `${Math.round(baseline.targetPanelHeight)}px`;

        if (state.scheme.id !== "vertical") {
          return;
        }
        const stageWrapRect = stageWrap.getBoundingClientRect();
        const wrapStyles = getComputedStyle(stageWrap);
        const padY =
          parseFloat(wrapStyles.paddingTop) + parseFloat(wrapStyles.paddingBottom);
        const borderY =
          parseFloat(wrapStyles.borderTopWidth) +
          parseFloat(wrapStyles.borderBottomWidth);
        const maxHeight = Math.max(
          baseline.resultsBottom - stageWrapRect.top - padY - borderY,
          160
        );
        stage.style.setProperty("--stage-max-height", `${Math.round(maxHeight)}px`);
      };

      const scheduleVerticalLayout = (shouldFit = false) => {
        if (shouldFit) {
          pendingFit = true;
        }
        if (verticalLayoutScheduled) return;
        verticalLayoutScheduled = true;
        window.requestAnimationFrame(() => {
          verticalLayoutScheduled = false;
          updateVerticalLayout();
          if (pendingFit && state.imageLoaded) {
            pendingFit = false;
            fitImageToStage();
          }
        });
      };

      const setImageLoadedState = (loaded) => {
        state.imageLoaded = loaded;
        stage.dataset.loaded = loaded ? "true" : "false";
        cropBtn.disabled = !loaded;
        rotateBtn.disabled = !loaded;
        mirrorBtn.disabled = !loaded;
      };

      const renderTiles = () => {
        tileGrid.innerHTML = "";
        tiles.length = 0;
        const { cols, rows } = state.scheme;
        tileGrid.style.setProperty("--cols", cols.toString());
        tileGrid.style.setProperty("--rows", rows.toString());

        for (let row = 0; row < rows; row += 1) {
          for (let col = 0; col < cols; col += 1) {
            const cell = document.createElement("div");
            cell.className = "tile-cell";
            if (row === 0 && col === 0) {
              cell.style.borderTopLeftRadius = "var(--stage-radius)";
            }
            if (row === 0 && col === cols - 1) {
              cell.style.borderTopRightRadius = "var(--stage-radius)";
            }
            if (row === rows - 1 && col === 0) {
              cell.style.borderBottomLeftRadius = "var(--stage-radius)";
            }
            if (row === rows - 1 && col === cols - 1) {
              cell.style.borderBottomRightRadius = "var(--stage-radius)";
            }
            const img = document.createElement("img");
            img.className = "tile-image";
            img.alt = "";
            img.draggable = false;
            cell.appendChild(img);
            tileGrid.appendChild(cell);
            tiles.push({ row, col, img });
          }
        }

        if (state.imageLoaded) {
          updateTileSources();
        }
        updateTileTransforms();
      };

      const setStageRatio = () => {
        const { cols, rows, cellW, cellH } = state.scheme;
        const ratio = (cellW / cellH) * (cols / rows);
        stage.style.setProperty("--stage-ratio", ratio.toString());
        stage.style.setProperty("--cols", cols.toString());
        stage.style.setProperty("--rows", rows.toString());
      };

      const updateTileSources = () => {
        const src = sourceImage.src;
        tiles.forEach((tile) => {
          tile.img.src = src;
        });
      };

      const updateTileTransforms = () => {
        if (!tiles.length) return;
        const { cellW, cellH } = getContentMetrics();

        tiles.forEach((tile) => {
          const tileX = tile.col * cellW;
          const tileY = tile.row * cellH;
          tile.img.style.transform = `translate(${state.offsetX - tileX}px, ${
            state.offsetY - tileY
          }px) scale(${state.scale})`;
        });
      };

      const updateZoomUI = () => {
        zoomRange.value = state.scale.toFixed(3);
        zoomValue.textContent = `${state.scale.toFixed(2)}x`;
      };

      const clampOffsets = () => {
        const { contentW, contentH } = getContentMetrics();
        const imgW = state.imgWidth * state.scale;
        const imgH = state.imgHeight * state.scale;
        const minX = contentW - imgW;
        const minY = contentH - imgH;
        state.offsetX = clamp(state.offsetX, minX, 0);
        state.offsetY = clamp(state.offsetY, minY, 0);
      };

      const applyTransform = () => {
        sourceImage.style.transform = `translate(${state.offsetX}px, ${state.offsetY}px) scale(${state.scale})`;
        updateTileTransforms();
      };

      const fitImageToStage = () => {
        const { contentW, contentH } = getContentMetrics();
        state.minScale = Math.max(contentW / state.imgWidth, contentH / state.imgHeight);
        state.maxScale = state.minScale * 3.5;
        state.scale = state.minScale;
        state.offsetX = (contentW - state.imgWidth * state.scale) / 2;
        state.offsetY = (contentH - state.imgHeight * state.scale) / 2;
        clampOffsets();
        zoomRange.min = state.minScale.toFixed(3);
        zoomRange.max = state.maxScale.toFixed(3);
        zoomRange.step = Math.max(state.minScale / 200, 0.001).toFixed(3);
        updateZoomUI();
        applyTransform();
      };

      const centerImage = () => {
        const { contentW, contentH } = getContentMetrics();
        state.offsetX = (contentW - state.imgWidth * state.scale) / 2;
        state.offsetY = (contentH - state.imgHeight * state.scale) / 2;
        clampOffsets();
        applyTransform();
      };

      const zoomTo = (newScale, focusX, focusY) => {
        const { rect, gap, cols, rows, cellW, cellH, contentW, contentH } = getContentMetrics();
        const fx = focusX ?? rect.width / 2;
        const fy = focusY ?? rect.height / 2;
        const contentFx = mapStageToContent(fx, cellW, gap, cols);
        const contentFy = mapStageToContent(fy, cellH, gap, rows);
        const imageX = (contentFx - state.offsetX) / state.scale;
        const imageY = (contentFy - state.offsetY) / state.scale;
        state.scale = clamp(newScale, state.minScale, state.maxScale);
        state.offsetX = clamp(contentFx - imageX * state.scale, contentW - state.imgWidth * state.scale, 0);
        state.offsetY = clamp(contentFy - imageY * state.scale, contentH - state.imgHeight * state.scale, 0);
        clampOffsets();
        applyTransform();
        updateZoomUI();
      };

      const setOutputEmpty = () => {
        outputGrid.innerHTML = '<div class="output-empty" aria-hidden="true"></div>';
      };

      const updateOutputLayout = () => {
        outputGrid.classList.toggle("vertical-stack", state.scheme.id === "vertical");
      };

      const updateMirrorLabel = () => {
        mirrorBtn.textContent = "ÈïúÂÉè";
      };

      const setSourceImage = (src) => {
        sourceImage.onload = () => {
          state.imgWidth = sourceImage.naturalWidth;
          state.imgHeight = sourceImage.naturalHeight;
          setImageLoadedState(true);
          updateMirrorLabel();
          updateTileSources();
          scheduleVerticalLayout(true);
          setOutputEmpty();
        };
        sourceImage.src = src;
      };

      const applyRotation = () => {
        if (!state.originalImage) return;
        const angle = (state.rotation + 360) % 360;
        const radians = (angle * Math.PI) / 180;
        const swap = angle % 180 !== 0;
        const canvas = document.createElement("canvas");
        canvas.width = swap ? state.originalImage.height : state.originalImage.width;
        canvas.height = swap ? state.originalImage.width : state.originalImage.height;
        const ctx = canvas.getContext("2d");
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(radians);
        ctx.scale(state.mirror ? -1 : 1, 1);
        ctx.drawImage(
          state.originalImage,
          -state.originalImage.width / 2,
          -state.originalImage.height / 2
        );
        setSourceImage(canvas.toDataURL("image/png"));
      };

      const rotateBy = (delta) => {
        if (!state.originalImage) return;
        state.rotation = (state.rotation + delta + 360) % 360;
        applyRotation();
      };

      const copyImage = async (dataUrl, button) => {
        if (!navigator.clipboard || !window.ClipboardItem) {
          button.textContent = "‰∏çÊîØÊåÅ";
          setTimeout(() => {
            button.textContent = "Â§çÂà∂";
          }, 1200);
          return;
        }

        try {
          const blob = await (await fetch(dataUrl)).blob();
          await navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]);
          button.textContent = "Â∑≤Â§çÂà∂";
          setTimeout(() => {
            button.textContent = "Â§çÂà∂";
          }, 1200);
        } catch (error) {
          button.textContent = "Â§±Ë¥•";
          setTimeout(() => {
            button.textContent = "Â§çÂà∂";
          }, 1200);
        }
      };

      const drawSlices = () => {
        if (!state.imageLoaded) return;
        const { cols, rows, cellW, cellH } = getContentMetrics();
        const { name } = state.scheme;
        outputGrid.innerHTML = "";

        let index = 0;
        for (let row = 0; row < rows; row += 1) {
          for (let col = 0; col < cols; col += 1) {
            index += 1;
            const sx = (col * cellW - state.offsetX) / state.scale;
            const sy = (row * cellH - state.offsetY) / state.scale;
            const sw = cellW / state.scale;
            const sh = cellH / state.scale;
            const canvas = document.createElement("canvas");
            canvas.width = Math.max(1, Math.round(sw));
            canvas.height = Math.max(1, Math.round(sh));
            const ctx = canvas.getContext("2d");
            ctx.drawImage(
              sourceImage,
              sx,
              sy,
              sw,
              sh,
              0,
              0,
              canvas.width,
              canvas.height
            );
            const dataUrl = canvas.toDataURL("image/png");

            const card = document.createElement("div");
            card.className = "output-card";
            const img = document.createElement("img");
            img.src = dataUrl;
            img.alt = `${name} ÂàáÁâá ${index}`;
            img.style.aspectRatio = `${canvas.width} / ${canvas.height}`;
            const meta = document.createElement("div");
            meta.className = "output-meta";
            const link = document.createElement("a");
            link.href = dataUrl;
            link.download = `xpost-${state.scheme.id}-${index}.png`;
            link.textContent = "‰∏ãËΩΩ";
            const copyBtn = document.createElement("button");
            copyBtn.type = "button";
            copyBtn.textContent = "Â§çÂà∂";
            copyBtn.addEventListener("click", () => {
              copyImage(dataUrl, copyBtn);
            });
            meta.appendChild(link);
            meta.appendChild(copyBtn);
            card.appendChild(img);
            card.appendChild(meta);
            outputGrid.appendChild(card);
          }
        }
      };

      const loadFile = (file) => {
        if (!file) return;
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => {
          URL.revokeObjectURL(url);
          state.originalImage = img;
          state.rotation = 0;
          state.mirror = false;
          applyRotation();
        };
        img.src = url;
      };

      fileInput.addEventListener("change", (event) => {
        const file = event.target.files[0];
        loadFile(file);
      });

      selectBtn.addEventListener("click", () => {
        fileInput.click();
      });

      uploadArea.addEventListener("dragover", (event) => {
        event.preventDefault();
        uploadArea.classList.add("dragging");
      });

      uploadArea.addEventListener("dragleave", () => {
        uploadArea.classList.remove("dragging");
      });

      uploadArea.addEventListener("drop", (event) => {
        event.preventDefault();
        uploadArea.classList.remove("dragging");
        const file = event.dataTransfer.files[0];
        loadFile(file);
      });

      document.addEventListener("paste", (event) => {
        const items = event.clipboardData?.items;
        if (!items) return;
        for (const item of items) {
          if (item.kind === "file" && item.type.startsWith("image/")) {
            const file = item.getAsFile();
            loadFile(file);
            break;
          }
        }
      });

      const updatePasteLabel = (text) => {
        pasteBtn.textContent = text;
        window.clearTimeout(pasteBtn._timer);
        pasteBtn._timer = window.setTimeout(() => {
          pasteBtn.textContent = "Á≤òË¥¥ÂõæÁâá";
        }, 1200);
      };

      const pasteFromClipboard = async () => {
        if (!navigator.clipboard || !navigator.clipboard.read) {
          updatePasteLabel("‰∏çÊîØÊåÅ");
          return;
        }

        try {
          const items = await navigator.clipboard.read();
          for (const item of items) {
            const type = item.types.find((itemType) => itemType.startsWith("image/"));
            if (type) {
              const blob = await item.getType(type);
              const file = new File([blob], "clipboard.png", { type });
              loadFile(file);
              updatePasteLabel("Â∑≤ÂØºÂÖ•");
              return;
            }
          }
          updatePasteLabel("Êó†ÂõæÁâá");
        } catch (error) {
          updatePasteLabel("Â§±Ë¥•");
        }
      };

      pasteBtn.addEventListener("click", () => {
        pasteFromClipboard();
      });

      document.querySelectorAll('input[name="scheme"]').forEach((input) => {
        input.addEventListener("change", (event) => {
          const value = event.target.value;
          state.scheme = schemes[value];
          setStageRatio();
          renderTiles();
          updateOutputLayout();
          if (state.imageLoaded) {
            scheduleVerticalLayout(true);
            setOutputEmpty();
          } else {
            scheduleVerticalLayout();
          }
        });
      });

      zoomRange.addEventListener("input", (event) => {
        const value = parseFloat(event.target.value);
        zoomTo(value);
      });

      fitBtn.addEventListener("click", () => {
        if (!state.imageLoaded) return;
        fitImageToStage();
      });

      centerBtn.addEventListener("click", () => {
        if (!state.imageLoaded) return;
        centerImage();
      });

      rotateBtn.addEventListener("click", () => {
        rotateBy(90);
      });

      mirrorBtn.addEventListener("click", () => {
        state.mirror = !state.mirror;
        updateMirrorLabel();
        applyRotation();
      });

      cropBtn.addEventListener("click", () => {
        drawSlices();
      });

      stage.addEventListener("pointerdown", (event) => {
        if (!state.imageLoaded) return;
        state.dragging = true;
        state.dragStartX = event.clientX;
        state.dragStartY = event.clientY;
        state.dragOriginX = state.offsetX;
        state.dragOriginY = state.offsetY;
        stage.setPointerCapture(event.pointerId);
      });

      stage.addEventListener("pointermove", (event) => {
        if (!state.dragging) return;
        const dx = event.clientX - state.dragStartX;
        const dy = event.clientY - state.dragStartY;
        state.offsetX = state.dragOriginX + dx;
        state.offsetY = state.dragOriginY + dy;
        clampOffsets();
        applyTransform();
      });

      stage.addEventListener("pointerup", (event) => {
        state.dragging = false;
        stage.releasePointerCapture(event.pointerId);
      });

      stage.addEventListener("pointerleave", () => {
        state.dragging = false;
      });

      stage.addEventListener(
        "wheel",
        (event) => {
          if (!state.imageLoaded) return;
          event.preventDefault();
          const delta = -event.deltaY * 0.001;
          const nextScale = state.scale * (1 + delta);
          const rect = stage.getBoundingClientRect();
          const focusX = event.clientX - rect.left;
          const focusY = event.clientY - rect.top;
          zoomTo(nextScale, focusX, focusY);
        },
        { passive: false }
      );

      window.addEventListener("resize", () => {
        scheduleVerticalLayout(state.imageLoaded);
      });

      setStageRatio();
      renderTiles();
      updateOutputLayout();
      scheduleVerticalLayout();
      setOutputEmpty();
    </script>
  </body>
</html>
